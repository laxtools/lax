#include "stdafx.h"
#include <catch.hpp>
#include <lax/net/service.hpp>
#include <lax/net/protocol/bits/bits_message.hpp>
#include <lax/net/protocol/bits/bits_protocol.hpp>
#include <lax/net/protocol/bits/bits_message_factory.hpp>
#include <lax/util/aes.hpp>

using namespace lax::net;

namespace
{

struct item
{
	int id = 1;
	int cost = 100;

	BITS_SERIALIZE(
		id,
		cost
	);
};

struct bm_flex : public bits_message
{
	BITS_MSG(
		3,				// group
		4,				// type
		bm_flex			// class 
	);

	std::string name;
	int value = 33;
	std::vector<item> items;

	BITS_SERIALIZE(
		name,
		value,
		items
	);
};

} // noname

TEST_CASE("bits protocol")
{
	SECTION("send / recv")
	{
		bits_protocol::cfg.enable_loopback = true;

		BITS_MSG_REG(bm_flex);

		std::shared_ptr<bm_flex> res;

		auto skey = session::sub(
			bm_flex::topic_key,
			[&res](lax::channel::message::ptr m) {
				res = std::static_pointer_cast<bm_flex>(m);
			}
		);

		auto mp = std::make_shared<bm_flex>();

		mp->name = "Hello";
		mp->value = 1;
		mp->items.push_back(item{ 10000, 77777 });

		auto proto = std::make_shared<bits_protocol>();

		proto->send(mp); // post in on_recv

		REQUIRE(res->name == mp->name);

		session::unsub(skey);
	}

	SECTION("modifier")
	{
		SECTION("aes test")
		{
			// usage 
			aes::context ctx;

			uint8_t iv[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
			uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };

			uint8_t in[] = { 
				0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
				0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
				0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
				0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 
			};

			uint8_t out[] = { 
				0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
				0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
				0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
				0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 
			};

			aes::init_with_iv(ctx, key, iv);

			aes::encrypt(ctx, out, 64);
			aes::decrypt(ctx, out, 64);

			REQUIRE(memcmp(in, out, 64) == 0);
		}

		SECTION("checksum modifier")
		{

		}

		SECTION("cipher modifier")
		{

		}
	}

	SECTION("checksum")
	{
		bits_protocol::cfg.enable_loopback = true;


	}

	SECTION("cipher")
	{
		bits_protocol::cfg.enable_loopback = true;

	}


	SECTION("session")
	{
		bits_protocol::cfg.enable_loopback = false;


	}
}